from pylab import *
from numpy.random import normal, random, randint
#from dream_fit import dream_fit
from dreamZPT.wrapper import DREAMZS

def iopos(day, par):
    '''
    Iopos calculates a model orbit for Io. 
    inputs:
    =======
    day = decimal day, or an array of decimal days
    par = parameter array for orbit

    The parameters are:
    par[0] = t_0, or time of conjunction
    par[1] = Amplitude of orbit (maximum elongation from Jupiter)
    par[2] = Period of orbit (in days if the time is in days)

    The function returns a model position for each date in the input
    day array.
    '''
    day0 = par[0]
    period = par[1]
    amp = par[2]
    iopos = amp*sin(2*pi*(day-day0)/period)
    return iopos

def logl(p): 
    model = iopos(day, p)
    chisq = sum(((pos - model)/dpos)**2)
    return -chisq/2.0

def logp(p):
    if p[0] < 0:
        return -inf
    if p[1] < 0.:
        return -inf
    if p[2] < 0.:
        return -inf
    return 0.

'''
Load the data, putting each column into a new variable.
'''
day, pos, dpos = loadtxt('io.txt', unpack=True)
'''
MCMC needs some prior estimate of the range of acceptable values. We
suspect the t0, the amplitude, and the period are all greater than 0,
so we'll take that as a low estimate for the parameters.
'''
plow = array([0., 0., 0.])
'''
On the other hand, a lazy assessment of the data suggest the parameter
values don't exceed 10. To get a better fit, it's better to spend some
time with plow and phigh.
'''
phigh = array([10., 10., 10.])

'''
Initialize Z with random values in the support range.
'''
from numpy.random import uniform
M0 = 10. * len(plow)
Z = zeros((len(plow),M0))
for i in range(len(plow)):
    Z[i,:] = plow[i] + (phigh[i] - plow[i]) * uniform(size=M0)



Z, ZP, success = DREAMZS(Z, logl, logp, 3, 10000, thin=10, ncr=-1)
# note: use verbose=False to turn off all the noise
'''
Z contains a history of all of the parameter values that were tried.
Z[:,0] = the random walk history of the day0 parameter
Z[:,1] = the random walk history of the orbital period
Z[:,2] = the random walk history of the amplitude parameter

ZP contains the history of log(likelihood). Larger (more positive)
values indicate an improved fit.
'''

''' 
Plot a model to see if it makes sense
'''
clf()
# plot the data
errorbar(day, pos, dpos, fmt='ko')
# plot the model
x = arange(5,40,0.1)
y = iopos(x, Z[-1,:]) # use the last parameter values
plot(x, y, 'r.')
# axis labels
xlabel('Day Number')
ylabel('Position of Io (Jups)')
savefig('ioOrbit.pdf')

''' 
Plot a histogram of the best fit values of the orbital period. For
now, I'll assume that only the last half of the history contains valid
data, but really you should check it by inspection.
'''

clf()
period = Z[:,1] # parameter 1, all samples
hist(period, bins=30)
ylabel('Frequency')
xlabel('Period (days)')
savefig('histogram.pdf')

''' 
Plot the parameter trace
'''
clf()
plot(period)
xlabel('Iteration')
ylabel('Period (days)')
savefig('trace.pdf')
